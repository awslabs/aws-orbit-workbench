kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: ebs-${team}-gp2
provisioner: kubernetes.io/aws-ebs
allowVolumeExpansion: true
reclaimPolicy: Delete
parameters:
  type: gp2
  fsType: ext4
  encrypted: "true"
  kmsKeyId: ${team_kms_key_arn}
volumeBindingMode: Immediate
---
apiVersion: v1
kind: PersistentVolume
metadata:
  labels:
    app: jupyterhub
    efs-id: ${efsid}
  name: jupyterhub-${team}
spec:
  accessModes:
    - ReadWriteMany
  capacity:
    storage: 5Gi
  csi:
    driver: efs.csi.aws.com
    volumeHandle: ${efsid}::${efsapid}
  persistentVolumeReclaimPolicy: Retain
  storageClassName: efs-storage-class
  volumeMode: Filesystem
---
apiVersion: v1
kind: Namespace
metadata:
  name: ${team}
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: jupyterhub
  namespace: ${team}
spec:
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 5Gi
  storageClassName: efs-storage-class
  volumeName: jupyterhub-${team}
---
apiVersion: v1
kind: ServiceAccount
metadata:
  labels:
    team: ${team}
  name: ${team}
  namespace: ${team}
  annotations:
    eks.amazonaws.com/role-arn: arn:aws:iam::${account_id}:role/orbit-${env_name}-${team}-role
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  labels:
    app: orbit-jupyterhub
  name: jupyterhub
  namespace: ${team}
rules:
  - apiGroups:
      - ""
    resources:
      - pods
      - persistentvolumeclaims
    verbs:
      - get
      - watch
      - list
      - create
      - delete
  - apiGroups:
      - ""
    resources:
      - events
    verbs:
      - get
      - watch
      - list
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  labels:
    app: orbit-jupyterhub
  name: jupyterhub
  namespace: ${team}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: jupyterhub
subjects:
  - kind: ServiceAccount
    name: ${team}
    namespace: ${team}
---
apiVersion: vpcresources.k8s.aws/v1beta1
kind: SecurityGroupPolicy
metadata:
  name: ${team}-security-group-policy
  namespace: ${team}
spec:
  podSelector:
    matchLabels:
      orbit/attach-security-group: "yes"
  securityGroups:
    groupIds:
      - ${team_security_group_id}
---
apiVersion: vpcresources.k8s.aws/v1beta1
kind: SecurityGroupPolicy
metadata:
  name: cluster-pod-security-group-policy
  namespace: ${team}
spec:
  podSelector:
    matchLabels:
      orbit/node-type: ec2
  securityGroups:
    groupIds:
      - ${cluster_pod_security_group_id}
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app: orbit-jupyterhub
  name: jupyterhub-private
  namespace: ${team}
spec:
  ports:
    - port: 8081
      protocol: TCP
      targetPort: 8081
  selector:
    app: orbit-jupyterhub
  type: ClusterIP
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app: orbit-jupyterhub
  name: jupyterhub-api
  namespace: ${team}
spec:
  ports:
    - port: 8001
      protocol: TCP
      targetPort: 8001
  selector:
    app: orbit-jupyterhub
  type: ClusterIP
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app: orbit-jupyterhub
  name: jupyterhub-public
  namespace: ${team}
  annotations:
      service.beta.kubernetes.io/aws-load-balancer-internal: ${internal_load_balancer}
spec:
  ports:
    - port: 80
      protocol: TCP
      targetPort: 8000
  selector:
    app: orbit-jupyterhub
  type: LoadBalancer
  loadBalancerSourceRanges: ${jupyterhub_inbound_ranges}
---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: orbit-jupyterhub
  name: jupyterhub
  namespace: ${team}
spec:
  replicas: 1
  selector:
    matchLabels:
      app: orbit-jupyterhub
  strategy:
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 1
    type: RollingUpdate
  template:
    metadata:
      labels:
        app: orbit-jupyterhub
        orbit/node-type: ec2
        orbit/attach-security-group: "yes"
      name: jupyterhub
    spec:
      containers:
        - image: ${account_id}.dkr.ecr.${region}.amazonaws.com/orbit-${env_name}-jupyter-hub:${tag}
          env:
            - name: AWS_DEFAULT_REGION
              value: ${region}
            - name: ENV_NAME
              value: ${env_name}
            - name: TEAM
              value: ${team}
            - name: GRANT_SUDO
              value: ${grant_sudo}
            - name: AWS_STS_REGIONAL_ENDPOINTS
              value: regional
          imagePullPolicy: Always
          name: container
          ports:
            - containerPort: 8080
            - containerPort: 8001
            - containerPort: 8081
          volumeMounts:
            - mountPath: /efs
              name: efs-volume
            - name: jupyterhub-config
              mountPath: /config
          resources:
            limits:
              cpu: "500m"
              memory: "2G"
            requests:
              cpu: "100m"
              memory: "512Mi"
      nodeSelector:
        orbit/usage: teams
        orbit/node-type: ec2
      serviceAccountName: ${team}
      securityContext:
        fsGroup: 100
      volumes:
        - name: efs-volume
          persistentVolumeClaim:
            claimName: jupyterhub
        - name: jupyterhub-config
          configMap:
            name: jupyterhub-config
            defaultMode: 0744
---
apiVersion: batch/v1
kind: Job
metadata:
  name: efs-init-${team}
  namespace: ${team}
  labels:
    app: orbit-jupyterhub
    volume: ${efsid}
    job-name: efs-init-${team}
spec:
  template:
    metadata:
      labels:
        orbit/node-type: ec2
        orbit/attach-security-group: "yes"
    spec:
      nodeSelector:
        orbit/usage: teams
        orbit/node-type: ec2
      serviceAccountName: ${team}
      containers:
      - name: run-efs-init
        securityContext:
          runAsUser: 0
        imagePullPolicy: Always
        image: ${account_id}.dkr.ecr.${region}.amazonaws.com/orbit-${env_name}-jupyter-user:${tag}
        command: ["/bin/bash"]
        resources:
          limits:
            cpu: "100m"
            memory: "100Mi"
          requests:
            cpu: "10m"
            memory: "20Mi"
        args:
          - -c
          - >-
            sudo chmod 777 /efs &&
            ls -ld /efs
        volumeMounts:
          - mountPath: /efs
            name: efs-volume
      volumes:
        - name: efs-volume
          persistentVolumeClaim:
            claimName: jupyterhub
      restartPolicy: Never

---

apiVersion: v1
kind: ConfigMap
metadata:
  name: jupyterhub-config
  namespace: ${team}
  labels:
    app: orbit-jupyterhub
data:
  jupyterhub_config.py: |
    import json
    import os
    import sys
    from typing import Any, Dict, List, cast

    import boto3
    from jupyterhub_utils.authenticator import OrbitWorkbenchAuthenticator
    from jupyterhub_utils.ssm import ACCOUNT_ID, ENV_NAME, GRANT_SUDO, IMAGE, REGION, TEAM, TOOLKIT_S3_BUCKET
    from tornado.log import app_log

    PROFILES_TYPE = List[Dict[str, Any]]

    app_log.info("ACCOUNT_ID: %s", ACCOUNT_ID)
    app_log.info("ENV_NAME: %s", ENV_NAME)
    app_log.info("IMAGE: %s", IMAGE)
    app_log.info("REGION: %s", REGION)
    app_log.info("TEAM: %s", TEAM)
    app_log.info("TOOLKIT_S3_BUCKET: %s", TOOLKIT_S3_BUCKET)
    app_log.info("GRANT_SUDO: %s", GRANT_SUDO)

    """
    CONNECTIVITY
    """

    c.JupyterHub.hub_connect_ip = os.environ["JUPYTERHUB_PRIVATE_SERVICE_HOST"]
    c.JupyterHub.hub_connect_port = int(os.environ["JUPYTERHUB_PRIVATE_SERVICE_PORT"])
    c.JupyterHub.hub_ip = "0.0.0.0"

    """
    SPAWNER
    """

    c.JupyterHub.spawner_class = "kubespawner.KubeSpawner"
    c.Spawner.default_url = "/lab"
    c.Spawner.cmd = ["/usr/local/bin/start-singleuser.sh", "-e", "CHOWN_EXTRA=/home/jovyan/.aws/cache"]
    c.Spawner.args = [
        "--SingleUserServerApp.default_url=/lab",
    ]
    c.KubeSpawner.start_timeout = 600
    c.KubeSpawner.common_labels = {"orbit/node-type": "ec2", "orbit/attach-security-group": "yes"}
    c.KubeSpawner.namespace = TEAM
    c.KubeSpawner.environment = {
        "JUPYTERHUB_SINGLEUSER_APP": "jupyter_server.serverapp.ServerApp",
        "USERNAME": lambda spawner: str(spawner.user.name),
        "JUPYTER_ENABLE_LAB": "yes",
        "AWS_ORBIT_TEAM_SPACE": TEAM,
        "AWS_ORBIT_ENV": ENV_NAME,
        "AWS_DEFAULT_REGION": REGION,
        "ACCOUNT_ID": ACCOUNT_ID,
        "AWS_ORBIT_S3_BUCKET": TOOLKIT_S3_BUCKET,
        "GRANT_SUDO": GRANT_SUDO,
        "AWS_STS_REGIONAL_ENDPOINTS": "regional",
    }
    if GRANT_SUDO == "yes":
        c.KubeSpawner.uid = 0

    c.KubeSpawner.image = IMAGE
    # can below if need to force image pull
    c.KubeSpawner.image_pull_policy = "Always"
    c.KubeSpawner.extra_annotations = {"AWS_ORBIT_TEAM_SPACE": TEAM, "AWS_ORBIT_ENV": ENV_NAME}
    pvc_name_template = "orbit-{username}-{servername}"
    c.KubeSpawner.pvc_name_template = pvc_name_template
    c.KubeSpawner.volumes = [{"name": "efs-volume", "persistentVolumeClaim": {"claimName": "jupyterhub"}}]
    c.KubeSpawner.volume_mounts = [{"mountPath": "/efs", "name": "efs-volume"}]
    c.KubeSpawner.fs_gid = 100
    c.KubeSpawner.lifecycle_hooks = {"postStart": {"exec": {"command": ["/bin/sh", "/home/jovyan/.orbit/bootstrap.sh"]}}}
    c.KubeSpawner.node_selector = {"orbit/usage": "teams", "orbit/node-type": "ec2"}
    c.KubeSpawner.service_account = f"{TEAM}"
    c.JupyterHub.allow_named_servers = True
    c.JupyterHub.named_server_limit_per_user = 5
    c.JupyterHub.services = [
        {
            "name": "idle-culler",
            "admin": True,
            "command": [sys.executable, "-m", "jupyterhub_idle_culler", "--remove-named-servers=True", "--timeout=28800"],
        },
        {
            "name": "voila-server",
            "url": "http://voila-service-private:4100/services/voila-server/",
            "admin": False,
        }
    ]
    profile_list_default = [
        {
            "display_name": "Nano",
            "slug": "nano",
            "description": "1 CPU + 1G MEM",
            "kubespawner_override": {
                "cpu_guarantee": 1,
                "cpu_limit": 1,
                "mem_guarantee": "1G",
                "mem_limit": "1G",
            },
        },
        {
            "display_name": "Micro",
            "slug": "micro",
            "description": "2 CPU + 2G MEM",
            "kubespawner_override": {
                "cpu_guarantee": 2,
                "cpu_limit": 2,
                "mem_guarantee": "2G",
                "mem_limit": "2G",
            },
            "default": True,
        },
        {
            "display_name": "Small",
            "slug": "small",
            "description": "4 CPU + 8G MEM",
            "kubespawner_override": {
                "cpu_guarantee": 4,
                "cpu_limit": 4,
                "mem_guarantee": "8G",
                "mem_limit": "8G",
            },
        },
    ]

    # reset the profile list so its loaded every time from SSM
    def userdata_hook(spawner, auth_state):
        spawner._profile_list = None


    c.Spawner.auth_state_hook = userdata_hook


    def per_user_profiles(spawner):
        ssm = boto3.Session().client("ssm")
        app_log.info("Getting profiles...")
        ssm_parameter_name: str = f"/orbit/{ENV_NAME}/teams/{TEAM}/context"
        json_str: str = ssm.get_parameter(Name=ssm_parameter_name)["Parameter"]["Value"]
        profiles = []
        team_manifest_dic = json.loads(json_str)
        if team_manifest_dic.get("Profiles"):
            profiles.extend(team_manifest_dic["Profiles"])
        else:
            app_log.info("No default profiles found")
            profiles.extend(profile_list_default)

        ssm_parameter_name: str = f"/orbit/{ENV_NAME}/teams/{TEAM}/user/profiles"
        json_str: str = ssm.get_parameter(Name=ssm_parameter_name)["Parameter"]["Value"]

        user_profiles: PROFILES_TYPE = cast(PROFILES_TYPE, json.loads(json_str))
        profiles.extend(user_profiles)
        return profiles


    c.KubeSpawner.profile_list = per_user_profiles

    """
    AUTH
    """

    c.JupyterHub.authenticator_class = OrbitWorkbenchAuthenticator
    c.Authenticator.auto_login = True

    """
    EXTRAS
    """

    c.JupyterHub.shutdown_on_logout = True
    c.JupyterHub.tornado_settings = {"slow_spawn_timeout": 360}
